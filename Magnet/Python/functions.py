import numpy as np
from math import *

u0 = pi*4.0e-7 # N/Am

def volume(D, t):
	"""
	Takes the diameter D and thickness t in meters
    calculates
	the volume of the cylinder in m3. (scalar)
	"""
	#f= 0.0254 # inch meter factor
	mD = D;
	mr = 0.5*mD;
	mt = t;
	V = pi*mr*mr*mt

	return V

def dipMoment(Br, V):
	"""
	Calculates the effective dipole moment of a
	cylindrical magnet. (scalar)
	Transforms Br in Gauss to TBr in Teslas
	"""
	TBr = Br*0.0001 # Gauss to Tesla
	m = V*TBr/u0 # A m2

	"""
	Correction factor due to unmodeled dynamics
	when calculating the moment
	"""

	CF = 1.0/14.891

	m = m*CF

	return m

# Now the hard part, work with vectors

# Define the magnetic moment vector

def dipMomentVec(m, i, j, k):
	"""
	Returns a vector given dipole moment magnitude
	The vector has direction i,j,k (must be 0 or 1)
	"""
	norm = sqrt(i*i + j*j + k*k) # normalizing factor
	mVec = (m/norm) * np.array([i,j,k])

	return mVec

def dipMomentVec2(m, dirvec):
	"""
	Returns a vector given dipole moment magnitude
	The vector has direction dirvec (a numpy array)
	"""
	norm =  np.linalg.norm(dirvec)
	mVec = (m/norm) * dirvec

	return mVec
	
def dipField(mVec, pVec, r0Vec):
	"""
	Returns the magnetic field components at pVec due  
	to the dipole mVec positioned at r0Vec in cartesian
	coordinates
	"""
	# Define rVec and its norm r
	rVec = pVec - r0Vec
	r = np.linalg.norm(rVec)
	
	B = (u0/4*pi)*((3*(mVec.dot(rVec)*rVec)/r**5)-mVec/r**3)
	
	return B[0], B[1], B[2], B

def dipfield2(mVec,r0Vec,x,y,z):
	
	rVecx = x - r0Vec[0]
	rVecy = y - r0Vec[1]
	rVecz = z - r0Vec[2]

	r = (rVecx**2 + rVecy**2 + rVecz**2)**0.5

	mdr = dotproduct(mVec[0],mVec[1],mVec[2],rVecx,rVecy,rVecz)

	Bx = (u0/4*pi)*((3*(mdr*rVecx)/(r**5))-mVec[0]/(r**3)) 
	By = (u0/4*pi)*((3*(mdr*rVecy)/(r**5))-mVec[1]/(r**3))
	Bz = (u0/4*pi)*((3*(mdr*rVecz)/(r**5))-mVec[2]/(r**3))

	return Bx, By, Bz

def dotproduct(x1,y1,z1,x2,y2,z2):
	
	m = x1*x2 + y1*y2 + z1*z2

	return m


def forceatpointconnector(case,x,y,z,dirvec):

	#Calculates the force of the magnet connector on 
	#a magnet in position x,y,z and orientation dirvec,
	#dirvec being a numpy array

	# MAGNET PARAMETERS, the same for all magnets
	f= 0.0254 #Conversion factor from inches to meters
	D = (1/2.0)*f; # Meters
	t = (1/8.0)*f; # Meters
	Br = 13200 # Gauss
	V = volume(D,t)
	m = dipMoment(Br, V) # Magnet scalar moment


	# Calculate dipole moment vector of the magnet
	# over which the force will be exerted
	mVec = dipMomentVec2(m, dirvec)

	# Expand points into meshgrid for later calculation
	# of the gradient

	# Define separation for array (affects precision)
	h = 0.0000001
	# Expand in array
	xa = np.array([x-2*h,x-h,x,x+h,x+2*h])
	ya = np.array([y-2*h,y-h,y,y+h,y+2*h])
	za = np.array([z-2*h,z-h,z,z+h,z+2*h])
	# Meshgrid
	X,Y,Z = np.meshgrid(xa,ya,za)

	#in two cases
	if case == 1:
		
	#	The connector is represented by one magnet at
	#	the origin with orientation i=1,j=0,k=0

		# POSITION/DIRECTION PARAMETERS
		# Position and direction of connector magnets

		# Position of magnet 0 (r0) in meters
		x0 = 0.0; y0 = 0.0; z0 = 0.0;
		r0Vec = np.array([x0, y0, z0])

		# Direction of magnet 0
		# will be normalized
		i = 1;j = 0;k = 0;
		dirvec0 = np.array([i,j,k])

		# Calculate magnet 0  moment vector
		mVec0 = dipMomentVec2(m, dirvec0)


		# MAGNETIC FIELD
		# Field of magnet 0 at grid points
		Bx0,By0,Bz0 = dipfield2(mVec0,r0Vec,X,Y,Z)

		# SCALAR FIELD
		# Dot product between the other magnet and 
		# the field generated by the connector magnets
		mdotB = dotproduct(mVec[0],mVec[1],mVec[2],Bx0,By0,Bz0) 

		# FORCE
		# Calculate gradient of scalar field given the array separation
		fyh,fxh,fzh = np.gradient(mdotB,h,h,h)
		# Find force components only in the point of interest
		fx = fxh[2][2][2]
		fy = fyh[2][2][2]
		fz = fzh[2][2][2]

		return fx,fy,fz

	elif case == 2:
		#	The connector is represented by four magnets at
		#	their connector positions with orientation i=1,j=0,k=0

		# POSITION/DIRECTION PARAMETERS
		# Position and direction of connector magnets

		# Position of magnet 0 (r0) in meters
		x0 = 0.0; y0 = 0.0; z0 = 0.018;
		r0Vec = np.array([x0, y0, z0])

		# Position of magnet 1 (r1) in meters
		x1 = 0.0; y1 = 0.018; z1 = 0.0;
		r1Vec = np.array([x1, y1, z1])

		# Position of magnet 2 (r2) in meters
		x2 = 0.0; y2 = 0.0; z2 = -0.018;
		r2Vec = np.array([x2, y2, z2])

		# Position of magnet 3 (r3) in meters
		x3 = 0.0; y3 = -0.018; z3 = 0.0;
		r3Vec = np.array([x3, y3, z3])

		# Direction of magnets 0,1,2,3
		# will be normalized
		i = 1;j = 0;k = 0;
		dirvec0123 = np.array([i,j,k])

		# Calculate magnet 0,1,2,3 moment vector
		mVec0123 = dipMomentVec2(m, dirvec0123)

		# MAGNETIC FIELD
		# Field of magnet 0 at grid points
		Bx0,By0,Bz0 = dipfield2(mVec0123,r0Vec,X,Y,Z)

		# Field of magnet 1 at grid points
		Bx1,By1,Bz1 = dipfield2(mVec0123,r1Vec,X,Y,Z)

		# Field of magnet 2 at grid points
		Bx2,By2,Bz2 = dipfield2(mVec0123,r2Vec,X,Y,Z)

		# Field of magnet 3 at grid points
		Bx3,By3,Bz3 = dipfield2(mVec0123,r3Vec,X,Y,Z)

		# Total magnetic field
		Bxt = Bx0 + Bx1 + Bx2 +Bx3
		Byt = By0 + By1 + By2 +By3
		Bzt = Bz0 + Bz1 + Bz2 +Bz3

		# SCALAR FIELD
		# Dot product between the other magnet and 
		# the field generated by the connector magnets
		mdotB = dotproduct(mVec[0],mVec[1],mVec[2],Bxt,Byt,Bzt) 

		# FORCE
		# Calculate gradient of scalar field given the array separation
		fyh,fxh,fzh = np.gradient(mdotB,h,h,h)
		# Find force components only in the point of interest
		fx = fxh[2][2][2]
		fy = fyh[2][2][2]
		fz = fzh[2][2][2]

		return fx,fy,fz






