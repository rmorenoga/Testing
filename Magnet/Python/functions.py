import numpy as np
from math import *

u0 = pi*4.0e-7 # N/Am

def volume(D, t):
	"""
	Takes the diameter D and thickness t in meters
    calculates
	the volume of the cylinder in m3. (scalar)
	"""
	#f= 0.0254 # inch meter factor
	mD = D;
	mr = 0.5*mD;
	mt = t;
	V = pi*mr*mr*mt

	return V

def dipMoment(Br, V):
	"""
	Calculates the effective dipole moment of a
	cylindrical magnet. (scalar)
	Transforms Br in Gauss to TBr in Teslas
	"""
	TBr = Br*0.0001 # Gauss to Tesla
	m = V*TBr/u0 # A m2

	"""
	Correction factor due to unmodeled dynamics
	when calculating the moment
	"""

	CF = 1.0/2.8#21.343
	m = m*CF

	return m

# Now the hard part, work with vectors

# Define the magnetic moment vector

def dipMomentVec(m, i, j, k):
	"""
	Returns a vector given dipole moment magnitude
	The vector has direction i,j,k (must be 0 or 1)
	"""
	norm = sqrt(i*i + j*j + k*k) # normalizing factor
	mVec = (m/norm) * np.array([i,j,k])

	return mVec

def dipMomentVec2(m, dirvec):
	"""
	Returns a vector given dipole moment magnitude
	The vector has direction dirvec (a numpy array)
	"""
	norm =  np.linalg.norm(dirvec)
	mVec = (m/norm) * dirvec

	return mVec
	
def dipField(mVec, pVec, r0Vec):
	"""
	Returns the magnetic field components at pVec due  
	to the dipole mVec positioned at r0Vec in cartesian
	coordinates
	"""
	# Define rVec and its norm r
	rVec = pVec - r0Vec
	r = np.linalg.norm(rVec)
	
	B = (u0/4*pi)*((3*(mVec.dot(rVec)*rVec)/r**5)-mVec/r**3)
	
	return B[0], B[1], B[2], B

def dipfield2(mVec,r0Vec,x,y,z):
	
	rVecx = x - r0Vec[0]
	rVecy = y - r0Vec[1]
	rVecz = z - r0Vec[2]

	r = (rVecx**2 + rVecy**2 + rVecz**2)**0.5

	mdr = dotproduct(mVec[0],mVec[1],mVec[2],rVecx,rVecy,rVecz)

	Bx = (u0/4*pi)*((3*(mdr*rVecx)/(r**5))-mVec[0]/(r**3)) 
	By = (u0/4*pi)*((3*(mdr*rVecy)/(r**5))-mVec[1]/(r**3))
	Bz = (u0/4*pi)*((3*(mdr*rVecz)/(r**5))-mVec[2]/(r**3))

	return Bx, By, Bz

def dotproduct(x1,y1,z1,x2,y2,z2):
	
	m = x1*x2 + y1*y2 + z1*z2

	return m


def forceatpointconnector(case,x,y,z,dirvec):

	#Calculates the force of the magnet connector on 
	#a magnet in position x,y,z and orientation dirvec,
	#dirvec being a numpy array

	# MAGNET PARAMETERS, the same for all magnets
	f= 0.0254 #Conversion factor from inches to meters
	D = (1/2.0)*f; # Meters
	t = (1/8.0)*f; # Meters
	Br = 13200 # Gauss
	V = volume(D,t)
	m = dipMoment(Br, V) # Magnet scalar moment


	# Calculate dipole moment vector of the magnet
	# over which the force will be exerted
	mVec = dipMomentVec2(m, dirvec)

	# Expand points into meshgrid for later calculation
	# of the gradient

	# Define separation for array (affects precision)
	h = 0.0000001
	# Expand in array
	xa = np.array([x-2*h,x-h,x,x+h,x+2*h])
	ya = np.array([y-2*h,y-h,y,y+h,y+2*h])
	za = np.array([z-2*h,z-h,z,z+h,z+2*h])
	# Meshgrid
	X,Y,Z = np.meshgrid(xa,ya,za)

	#in two cases
	if case == 1:
		
	#	The connector is represented by one magnet at
	#	the origin with orientation i=1,j=0,k=0

		# POSITION/DIRECTION PARAMETERS
		# Position and direction of connector magnets

		# Position of magnet 0 (r0) in meters
		x0 = 0.0; y0 = 0.0; z0 = 0.0;
		r0Vec = np.array([x0, y0, z0])

		# Direction of magnet 0
		# will be normalized
		i = 1;j = 0;k = 0;
		dirvec0 = np.array([i,j,k])

		# Calculate magnet 0  moment vector
		mVec0 = dipMomentVec2(m, dirvec0)


		# MAGNETIC FIELD
		# Field of magnet 0 at grid points
		Bx0,By0,Bz0 = dipfield2(mVec0,r0Vec,X,Y,Z)

		# SCALAR FIELD
		# Dot product between the other magnet and 
		# the field generated by the connector magnets
		mdotB = dotproduct(mVec[0],mVec[1],mVec[2],Bx0,By0,Bz0) 

		# FORCE
		# Calculate gradient of scalar field given the array separation
		fyh,fxh,fzh = np.gradient(mdotB,h,h,h)
		# Find force components only in the point of interest
		fx = fxh[2][2][2]
		fy = fyh[2][2][2]
		fz = fzh[2][2][2]

		return fx,fy,fz

	elif case == 2:
		#	The connector is represented by four magnets at
		#	their connector positions with orientation i=1,j=0,k=0

		# POSITION/DIRECTION PARAMETERS
		# Position and direction of connector magnets

		# Position of magnet 0 (r0) in meters
		x0 = 0.0; y0 = 0.0; z0 = 0.018;
		r0Vec = np.array([x0, y0, z0])

		# Position of magnet 1 (r1) in meters
		x1 = 0.0; y1 = 0.018; z1 = 0.0;
		r1Vec = np.array([x1, y1, z1])

		# Position of magnet 2 (r2) in meters
		x2 = 0.0; y2 = 0.0; z2 = -0.018;
		r2Vec = np.array([x2, y2, z2])

		# Position of magnet 3 (r3) in meters
		x3 = 0.0; y3 = -0.018; z3 = 0.0;
		r3Vec = np.array([x3, y3, z3])

		# Direction of magnets 0,1,2,3
		# will be normalized
		i = 1;j = 0;k = 0;
		dirvec0123 = np.array([i,j,k])

		# Calculate magnet 0,1,2,3 moment vector
		mVec0123 = dipMomentVec2(m, dirvec0123)

		# MAGNETIC FIELD
		# Field of magnet 0 at grid points
		Bx0,By0,Bz0 = dipfield2(mVec0123,r0Vec,X,Y,Z)

		# Field of magnet 1 at grid points
		Bx1,By1,Bz1 = dipfield2(mVec0123,r1Vec,X,Y,Z)

		# Field of magnet 2 at grid points
		Bx2,By2,Bz2 = dipfield2(mVec0123,r2Vec,X,Y,Z)

		# Field of magnet 3 at grid points
		Bx3,By3,Bz3 = dipfield2(mVec0123,r3Vec,X,Y,Z)

		# Total magnetic field
		Bxt = Bx0 + Bx1 + Bx2 +Bx3
		Byt = By0 + By1 + By2 +By3
		Bzt = Bz0 + Bz1 + Bz2 +Bz3

		# SCALAR FIELD
		# Dot product between the other magnet and 
		# the field generated by the connector magnets
		mdotB = dotproduct(mVec[0],mVec[1],mVec[2],Bxt,Byt,Bzt) 

		# FORCE
		# Calculate gradient of scalar field given the array separation
		fyh,fxh,fzh = np.gradient(mdotB,h,h,h)
		# Find force components only in the point of interest
		fx = fxh[2][2][2]
		fy = fyh[2][2][2]
		fz = fzh[2][2][2]

		return fx,fy,fz


def forceonconnector(x,dirvec):
	# Calculates the force and momentum of one connector placed at
	# the origin facing in direction i=1,j=0,k=0
	# on another connector placed in postion x
	# and orientation dirvec
	# x is a numpy array
	# dirvec is a numpy array that will be normalized

	# Arrange magnets in second connector
	# Center of connector
	center = x
	# Initial direction of connector i=1,j=0,k=0
	initdir = np.array([1,0,0])

	# Normalize dirvec
	dirvec = dirvec/np.linalg.norm(dirvec)

	# Find rotation matrix from initdir to dirvec
	if np.array_equal(initdir,dirvec):
		R = np.identity(3)
	else:
    	# Find axis of rotation
		v = np.cross(initdir,dirvec)
    	# Find sine of rotation angle
		s = np.linalg.norm(v)
    	# Find cosine of rotation angle
		c = initdir.dot(dirvec)
    	# Form skew-symetric cross product matrix from v
		skv = np.array([[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]])
		#skv = np.roll(np.roll(np.diag(v.flatten()), 1, 1), -1, 0)
		#skv = skv - skv.T
    	# Find rotation matrix
		R = np.identity(3) + skv + ((1-c)/(s**2))*(skv.dot(skv))

	# Original positions from center
	#Position of magnet 10
	rc10Vec = np.array([0.0,0.0,0.018])

	#Position of magnet 11
	rc11Vec = np.array([0.0,0.018,0.0])

	#Position of magnet 12
	rc12Vec = np.array([0.0,0.0,-0.018])

	#Position of magnet 13
	rc13Vec = np.array([0.0,-0.018,0.0])

	# Rotated positions from center
	rc10Vec = R.dot(rc10Vec)
	rc11Vec = R.dot(rc11Vec)
	rc12Vec = R.dot(rc12Vec)
	rc13Vec = R.dot(rc13Vec)

	# Positions from origin
	r10Vec = rc10Vec + center
	r11Vec = rc11Vec + center
	r12Vec = rc12Vec + center
	r13Vec = rc13Vec + center

	#Calculate force on each magnet
	fx10,fy10,fz10 = forceatpointconnector(2,r10Vec[0],r10Vec[1],r10Vec[2],dirvec)
	fx11,fy11,fz11 = forceatpointconnector(2,r11Vec[0],r11Vec[1],r11Vec[2],dirvec)
	fx12,fy12,fz12 = forceatpointconnector(2,r12Vec[0],r12Vec[1],r12Vec[2],dirvec)
	fx13,fy13,fz13 = forceatpointconnector(2,r13Vec[0],r13Vec[1],r13Vec[2],dirvec)

	f10 = np.array([fx10,fy10,fz10])
	f11 = np.array([fx11,fy11,fz11])
	f12 = np.array([fx12,fy12,fz12])
	f13 = np.array([fx13,fy13,fz13])

	# Total force on connector
	F = f10 + f11 + f12 + f13

	# Find moment due to each magnet from center of connector
	m10 = np.cross(rc10Vec,f10)
	m11 = np.cross(rc11Vec,f11)
	m12 = np.cross(rc12Vec,f12)
	m13 = np.cross(rc13Vec,f13)

	# Total moment on the center of connector
	M = m10 + m11 + m12 + m13

	return (F,M,f10,f11,f12,f13,m10,m11,m12,m13,r10Vec,r11Vec,r12Vec,r13Vec)






	







